// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"gitlab.slade360emr.com/go/base"
	"gitlab.slade360emr.com/go/clinical/graph/clinical"
)

// FHIRContactDetail definition: specifies contact information for a person or organization.
type FHIRContactDetail struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The name of an individual to contact.
	Name *string `json:"Name"`
	// The contact details for the individual (if a name was provided) or the organization.
	Telecom []*clinical.FHIRContactPoint `json:"Telecom"`
}

// FHIRContactDetailInput: input for ContactDetail
type FHIRContactDetailInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The name of an individual to contact.
	Name *string `json:"Name"`
	// The contact details for the individual (if a name was provided) or the organization.
	Telecom []*clinical.FHIRContactPointInput `json:"Telecom"`
}

// FHIRContributor definition: a contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
type FHIRContributor struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The type of contributor.
	Type *ContributorTypeEnum `json:"Type"`
	// The name of the individual or organization responsible for the contribution.
	Name *string `json:"Name"`
	// Contact details to assist a user in finding and communicating with the contributor.
	Contact []*FHIRContactDetail `json:"Contact"`
}

// FHIRContributorInput: input for Contributor
type FHIRContributorInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The type of contributor.
	Type *ContributorTypeEnum `json:"Type"`
	// The name of the individual or organization responsible for the contribution.
	Name *string `json:"Name"`
	// Contact details to assist a user in finding and communicating with the contributor.
	Contact []*FHIRContactDetailInput `json:"Contact"`
}

// FHIRCount definition: a measured amount (or an amount that can potentially be measured). note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
type FHIRCount struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The value of the measured amount. The value includes an implicit precision in the presentation of the value.
	Value *base.Decimal `json:"Value"`
	// How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
	Comparator *CountComparatorEnum `json:"Comparator"`
	// A human-readable form of the unit.
	Unit *string `json:"Unit"`
	// The identification of the system that provides the coded form of the unit.
	System *base.URI `json:"System"`
	// A computer processable form of the unit in some unit representation system.
	Code *base.Code `json:"Code"`
}

// FHIRCountInput: input for Count
type FHIRCountInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The value of the measured amount. The value includes an implicit precision in the presentation of the value.
	Value *base.Decimal `json:"Value"`
	// How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
	Comparator *CountComparatorEnum `json:"Comparator"`
	// A human-readable form of the unit.
	Unit *string `json:"Unit"`
	// The identification of the system that provides the coded form of the unit.
	System *base.URI `json:"System"`
	// A computer processable form of the unit in some unit representation system.
	Code *base.Code `json:"Code"`
}

// FHIRDataRequirement definition: describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
type FHIRDataRequirement struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The type of the required data, specified as the type name of a resource. For profiles, this value is set to the type of the base resource of the profile.
	Type *base.Code `json:"Type"`
	// The profile of the required data, specified as the uri of the profile definition.
	Profile []*base.Canonical `json:"Profile"`
	// The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
	SubjectCodeableConcept *base.Code `json:"SubjectCodeableConcept"`
	// The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
	SubjectReference *clinical.FHIRReference `json:"SubjectReference"`
	//     Indicates that specific elements of the type are referenced by the knowledge module and must be supported by the consumer in order to obtain an effective evaluation. This does not mean that a value is required for this element, only that the consuming system must understand the element and be able to provide values for it if they are available.
	//
	// The value of mustSupport SHALL be a FHIRPath resolveable on the type of the DataRequirement. The path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
	MustSupport []*string `json:"MustSupport"`
	// Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
	CodeFilter *base.Code `json:"CodeFilter"`
	// Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
	DateFilter *base.Date `json:"DateFilter"`
	// Specifies a maximum number of results that are required (uses the _count search parameter).
	Limit *string `json:"Limit"`
	// Specifies the order of the results to be returned.
	Sort []*FHIRDatarequirementSort `json:"Sort"`
}

// FHIRDataRequirementInput: input for DataRequirement
type FHIRDataRequirementInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The type of the required data, specified as the type name of a resource. For profiles, this value is set to the type of the base resource of the profile.
	Type *base.Code `json:"Type"`
	// The profile of the required data, specified as the uri of the profile definition.
	Profile *base.Canonical `json:"Profile"`
	// The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
	SubjectCodeableConcept *base.Code `json:"SubjectCodeableConcept"`
	// The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
	SubjectReference *clinical.FHIRReferenceInput `json:"SubjectReference"`
	//     Indicates that specific elements of the type are referenced by the knowledge module and must be supported by the consumer in order to obtain an effective evaluation. This does not mean that a value is required for this element, only that the consuming system must understand the element and be able to provide values for it if they are available.
	//
	// The value of mustSupport SHALL be a FHIRPath resolveable on the type of the DataRequirement. The path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
	MustSupport *string `json:"MustSupport"`
	// Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
	CodeFilter *base.Code `json:"CodeFilter"`
	// Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
	DateFilter *base.Date `json:"DateFilter"`
	// Specifies a maximum number of results that are required (uses the _count search parameter).
	Limit *string `json:"Limit"`
	// Specifies the order of the results to be returned.
	Sort []*FHIRDatarequirementSortInput `json:"Sort"`
}

// FHIRDatarequirementCodefilter definition: describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
type FHIRDatarequirementCodefilter struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The code-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type code, Coding, or CodeableConcept.
	Path *string `json:"Path"`
	// A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
	SearchParam *string `json:"SearchParam"`
	// The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
	ValueSet *base.Canonical `json:"ValueSet"`
	// The codes for the code filter. If values are given, the filter will return only those data items for which the code-valued attribute specified by the path has a value that is one of the specified codes. If codes are specified in addition to a value set, the filter returns items matching a code in the value set or one of the specified codes.
	Code *base.Code `json:"Code"`
}

// FHIRDatarequirementCodefilterInput: input for DatarequirementCodefilter
type FHIRDatarequirementCodefilterInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The code-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type code, Coding, or CodeableConcept.
	Path *string `json:"Path"`
	// A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
	SearchParam *string `json:"SearchParam"`
	// The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
	ValueSet *base.Canonical `json:"ValueSet"`
	// The codes for the code filter. If values are given, the filter will return only those data items for which the code-valued attribute specified by the path has a value that is one of the specified codes. If codes are specified in addition to a value set, the filter returns items matching a code in the value set or one of the specified codes.
	Code *base.Code `json:"Code"`
}

// FHIRDatarequirementDatefilter definition: describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
type FHIRDatarequirementDatefilter struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The date-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type date, dateTime, Period, Schedule, or Timing.
	Path *string `json:"Path"`
	// A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
	SearchParam *string `json:"SearchParam"`
	// The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
	ValueDateTime *base.Date `json:"ValueDateTime"`
	// The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
	ValuePeriod *clinical.FHIRPeriod `json:"ValuePeriod"`
	// The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
	ValueDuration *clinical.FHIRDuration `json:"ValueDuration"`
}

// FHIRDatarequirementDatefilterInput: input for DatarequirementDatefilter
type FHIRDatarequirementDatefilterInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The date-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type date, dateTime, Period, Schedule, or Timing.
	Path *string `json:"Path"`
	// A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
	SearchParam *string `json:"SearchParam"`
	// The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
	ValueDateTime *base.Date `json:"ValueDateTime"`
	// The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
	ValuePeriod *clinical.FHIRPeriodInput `json:"ValuePeriod"`
	// The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
	ValueDuration *clinical.FHIRDurationInput `json:"ValueDuration"`
}

// FHIRDatarequirementSort definition: describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
type FHIRDatarequirementSort struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
	Path *string `json:"Path"`
	// The direction of the sort, ascending or descending.
	Direction *DataRequirementSortDirectionEnum `json:"Direction"`
}

// FHIRDatarequirementSortInput: input for DatarequirementSort
type FHIRDatarequirementSortInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
	Path *string `json:"Path"`
	// The direction of the sort, ascending or descending.
	Direction *DataRequirementSortDirectionEnum `json:"Direction"`
}

// FHIRDistance definition: a length - a value with a unit that is a physical distance.
type FHIRDistance struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The value of the measured amount. The value includes an implicit precision in the presentation of the value.
	Value *base.Decimal `json:"Value"`
	// How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
	Comparator *DistanceComparatorEnum `json:"Comparator"`
	// A human-readable form of the unit.
	Unit *string `json:"Unit"`
	// The identification of the system that provides the coded form of the unit.
	System *base.URI `json:"System"`
	// A computer processable form of the unit in some unit representation system.
	Code *base.Code `json:"Code"`
}

// FHIRDistanceInput: input for Distance
type FHIRDistanceInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// The value of the measured amount. The value includes an implicit precision in the presentation of the value.
	Value *base.Decimal `json:"Value"`
	// How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
	Comparator *DistanceComparatorEnum `json:"Comparator"`
	// A human-readable form of the unit.
	Unit *string `json:"Unit"`
	// The identification of the system that provides the coded form of the unit.
	System *base.URI `json:"System"`
	// A computer processable form of the unit in some unit representation system.
	Code *base.Code `json:"Code"`
}

// FHIRMoney definition: an amount of economic utility in some recognized currency.
type FHIRMoney struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// Numerical value (with implicit precision).
	Value *base.Decimal `json:"Value"`
	// ISO 4217 Currency Code.
	Currency *base.Code `json:"Currency"`
}

// FHIRMoneyInput: input for Money
type FHIRMoneyInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// Numerical value (with implicit precision).
	Value *base.Decimal `json:"Value"`
	// ISO 4217 Currency Code.
	Currency *base.Code `json:"Currency"`
}

// FHIRSignature definition: a signature along with supporting context. the signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. this other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony different signature approaches have different utilities.
type FHIRSignature struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
	Type []*clinical.FHIRCoding `json:"Type"`
	// When the digital signature was signed.
	When *base.Instant `json:"When"`
	// A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
	Who *clinical.FHIRReference `json:"Who"`
	// A reference to an application-usable description of the identity that is represented by the signature.
	OnBehalfOf *clinical.FHIRReference `json:"OnBehalfOf"`
	// A mime type that indicates the technical format of the target resources signed by the signature.
	TargetFormat *base.Code `json:"TargetFormat"`
	// A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
	SigFormat *base.Code `json:"SigFormat"`
	// The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
	Data *base.Base64Binary `json:"Data"`
}

// FHIRSignatureInput: input for Signature
type FHIRSignatureInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
	Type []*clinical.FHIRCodingInput `json:"Type"`
	// When the digital signature was signed.
	When *base.Instant `json:"When"`
	// A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
	Who *clinical.FHIRReferenceInput `json:"Who"`
	// A reference to an application-usable description of the identity that is represented by the signature.
	OnBehalfOf *clinical.FHIRReferenceInput `json:"OnBehalfOf"`
	// A mime type that indicates the technical format of the target resources signed by the signature.
	TargetFormat *base.Code `json:"TargetFormat"`
	// A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
	SigFormat *base.Code `json:"SigFormat"`
	// The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
	Data *base.Base64Binary `json:"Data"`
}

// FHIRUsageContext definition: specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. this metadata can either be specific to the applicable population (e.g., age category, drg) or the specific context of care (e.g., venue, care setting, provider of care).
type FHIRUsageContext struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// A code that identifies the type of context being specified by this usage context.
	Code base.Code `json:"Code"`
	// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
	ValueCodeableConcept *base.Code `json:"ValueCodeableConcept"`
	// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
	ValueQuantity *clinical.FHIRQuantity `json:"ValueQuantity"`
	// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
	ValueRange *clinical.FHIRRange `json:"ValueRange"`
	// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
	ValueReference *clinical.FHIRReference `json:"ValueReference"`
}

// FHIRUsageContextInput: input for UsageContext
type FHIRUsageContextInput struct {
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	ID *string `json:"ID"`
	// A code that identifies the type of context being specified by this usage context.
	Code base.Code `json:"Code"`
	// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
	ValueCodeableConcept *base.Code `json:"ValueCodeableConcept"`
	// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
	ValueQuantity *clinical.FHIRQuantityInput `json:"ValueQuantity"`
	// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
	ValueRange *clinical.FHIRRangeInput `json:"ValueRange"`
	// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
	ValueReference *clinical.FHIRReferenceInput `json:"ValueReference"`
}

// ContributorTypeEnum is a FHIR enum
type ContributorTypeEnum string

const (
	ContributorTypeEnumAuthor   ContributorTypeEnum = "author"
	ContributorTypeEnumEditor   ContributorTypeEnum = "editor"
	ContributorTypeEnumReviewer ContributorTypeEnum = "reviewer"
	ContributorTypeEnumEndorser ContributorTypeEnum = "endorser"
)

var AllContributorTypeEnum = []ContributorTypeEnum{
	ContributorTypeEnumAuthor,
	ContributorTypeEnumEditor,
	ContributorTypeEnumReviewer,
	ContributorTypeEnumEndorser,
}

func (e ContributorTypeEnum) IsValid() bool {
	switch e {
	case ContributorTypeEnumAuthor, ContributorTypeEnumEditor, ContributorTypeEnumReviewer, ContributorTypeEnumEndorser:
		return true
	}
	return false
}

func (e ContributorTypeEnum) String() string {
	return string(e)
}

func (e *ContributorTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContributorTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContributorTypeEnum", str)
	}
	return nil
}

func (e ContributorTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CountComparatorEnum is a FHIR enum
type CountComparatorEnum string

const (
	CountComparatorEnumLessThan             CountComparatorEnum = "less_than"
	CountComparatorEnumLessThanOrEqualTo    CountComparatorEnum = "less_than_or_equal_to"
	CountComparatorEnumGreaterThanOrEqualTo CountComparatorEnum = "greater_than_or_equal_to"
	CountComparatorEnumGreaterThan          CountComparatorEnum = "greater_than"
)

var AllCountComparatorEnum = []CountComparatorEnum{
	CountComparatorEnumLessThan,
	CountComparatorEnumLessThanOrEqualTo,
	CountComparatorEnumGreaterThanOrEqualTo,
	CountComparatorEnumGreaterThan,
}

func (e CountComparatorEnum) IsValid() bool {
	switch e {
	case CountComparatorEnumLessThan, CountComparatorEnumLessThanOrEqualTo, CountComparatorEnumGreaterThanOrEqualTo, CountComparatorEnumGreaterThan:
		return true
	}
	return false
}

func (e CountComparatorEnum) String() string {
	return string(e)
}

func (e *CountComparatorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountComparatorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CountComparatorEnum", str)
	}
	return nil
}

func (e CountComparatorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DataRequirementSortDirectionEnum is a FHIR enum
type DataRequirementSortDirectionEnum string

const (
	DataRequirementSortDirectionEnumAscending  DataRequirementSortDirectionEnum = "ascending"
	DataRequirementSortDirectionEnumDescending DataRequirementSortDirectionEnum = "descending"
)

var AllDataRequirementSortDirectionEnum = []DataRequirementSortDirectionEnum{
	DataRequirementSortDirectionEnumAscending,
	DataRequirementSortDirectionEnumDescending,
}

func (e DataRequirementSortDirectionEnum) IsValid() bool {
	switch e {
	case DataRequirementSortDirectionEnumAscending, DataRequirementSortDirectionEnumDescending:
		return true
	}
	return false
}

func (e DataRequirementSortDirectionEnum) String() string {
	return string(e)
}

func (e *DataRequirementSortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataRequirementSortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DataRequirementSortDirectionEnum", str)
	}
	return nil
}

func (e DataRequirementSortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DistanceComparatorEnum is a FHIR enum
type DistanceComparatorEnum string

const (
	DistanceComparatorEnumLessThan             DistanceComparatorEnum = "less_than"
	DistanceComparatorEnumLessThanOrEqualTo    DistanceComparatorEnum = "less_than_or_equal_to"
	DistanceComparatorEnumGreaterThanOrEqualTo DistanceComparatorEnum = "greater_than_or_equal_to"
	DistanceComparatorEnumGreaterThan          DistanceComparatorEnum = "greater_than"
)

var AllDistanceComparatorEnum = []DistanceComparatorEnum{
	DistanceComparatorEnumLessThan,
	DistanceComparatorEnumLessThanOrEqualTo,
	DistanceComparatorEnumGreaterThanOrEqualTo,
	DistanceComparatorEnumGreaterThan,
}

func (e DistanceComparatorEnum) IsValid() bool {
	switch e {
	case DistanceComparatorEnumLessThan, DistanceComparatorEnumLessThanOrEqualTo, DistanceComparatorEnumGreaterThanOrEqualTo, DistanceComparatorEnumGreaterThan:
		return true
	}
	return false
}

func (e DistanceComparatorEnum) String() string {
	return string(e)
}

func (e *DistanceComparatorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistanceComparatorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DistanceComparatorEnum", str)
	}
	return nil
}

func (e DistanceComparatorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
